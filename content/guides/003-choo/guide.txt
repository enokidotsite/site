title: Choo and Fun Functional JS
----
date: September 1st, 2017
----
tags:
  - pre-alpha
  - beginner
----
thumbnail: choo-thumb.png
----
excerpt: Making a website doesn’t have to be hard, and programming doesn’t have to be complex. Choo is a small front-end “framework” which is easy to understand and works with the browser, not against it.
----
text:

![](/guides/003-choo/choo-thumb.png)

Sites today don’t look like yesterday’s sites. The tools and methods for making them don’t either. Most of the tools are much more complex. There are some good ideas in the complexity, though, and those can be focused into simpler and understandable tools.

Some of those best ideas are in [Choo](https://github.com/choojs/choo), which is as much a philosophy of building sites as it is a (tiny) front-end framework: 

> We believe programming should be fun and light, not stern and stressful. Using serious words without explaining them doesn't make for better results—if anything it scares people off. We don't want to be scary, we want to be nice and fun, and then casually be the best choice around. Real casually.

Because of this, Choo is the default framework for Enoki. Below are some general thoughts on the state of programming, and some practical examples of how to use Choo for your new project.

### On Frameworks

#### Big and small

Frameworks come in all sizes. Some are large and tightly bound, often solving problems in ways which aren’t relevant outside of the framework. Others are small and built to act as glue between specialized modules that you can easily swap.

Generally when working with a framework it’s easiest to work with a one that is a collection of smaller modules and exposes as much vanilla javascript as possible. This introduces all sorts of benefits, including the possibility to adjust the framework for your needs.

For instance, Choo is glue between a [few](https://github.com/shama/bel) [primary](https://github.com/choojs/nanorouter) [components](https://github.com/choojs/nanomorph). Want to use virtual DOM instead of `bel`? It’s easy to swap out for [`preact`](https://github.com/yoshuawuyts/rooch), although there are some good reasons to use [the DOM](https://github.com/patrick-steele-idem/morphdom#what-about-the-virtual-dom), but the point is you aren’t locked into any “right” way of doing it. Choo also uses `prototype`, so you can even override internal functions.

#### Appropriate technology

In trying to solve a lot of problems, these larger frameworks introduce a a lot of bloat to your build, as you may only be using a small amount of the possible functionality. It’s impossible to account for every situation, and these frameworks get deeper in the hole with solutions which aren’t relevant as time passes.

Choo considers itself disposable from the start, and doesn’t believe it will be top of the class forever, so it’s as easy to toss out as it is to pick up thanks to it’s modular and swappable design. You want to be learning javascript; not a framework.

#### Legal loopholes

Some frameworks include [gross legal backdoors](https://medium.com/@raulk/if-youre-a-startup-you-should-not-use-react-reflecting-on-the-bsd-patents-license-b049d4a67dd2) into your projects.

### Choo and Enoki

#### Static HTML rendering

Not only do you get webapp functionality, but you also get pre-render static HTML output for each of your routes. You get all the benefits of server-side rendering ([SSR](https://medium.com/walmartlabs/the-benefits-of-server-side-rendering-over-client-side-rendering-5d07ff2cefe8)) without any of the complication, plus the simplicity of the possibility to host your site on any static host and the archivability of running anywhere.

### When Aboard the Choo Train

#### To manipulate DOM directly use `nanocomponent`

[Nanocomponent](https://github.com/choojs/nanocomponent) works somewhat similarly to React components, enabling you to manually morph child elements and determine when to update. This is useful for things like Google Map embeds, video players, potentially heavy js animations,  etc…

#### Keep as much state at the top level as possible

Instead of storing a lot of internal state within components, try passing it in as `props` and then back up via handler function or two. This will make it much easier to work with from the rest of your build.

#### Check for `window`

Because Enoki uses Choo to generate static HTML, `window` will sometimes not be available. To get around this, add event listeners during Choo’s [`DOMContentLoaded`](https://github.com/choojs/choo#domcontentloadedstateeventsdomcontentloaded) event and check for window:

```js
var choo = require('choo')
var app = choo()

app.use(example)

// node or browser init
if (module.parent) module.exports = app
else app.mount('main')

function example (state, emitter) {
  state.example = false

  emitter.on(state.events.DOMCONTENTLOADED, handleLoad)

  function handleLoad () {
    if (typeof window !== 'undefined') state.example = true
    emitter.emit(state.events.RENDER)
  }
}
```